#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'json'
require 'fileutils'

require_relative 'classes/patch'
require_relative 'classes/arraystruct.rb'
require_relative 'classes/functions'
require_relative 'classes/os'
require_relative 'classes/library'
require_relative 'classes/fetch'
require_relative 'classes/unpack'
require_relative 'classes/build'
require_relative 'classes/install'
require_relative 'classes/platforms'
require_relative 'classes/exec'

current_dir = Dir.pwd

def showBanner
	return unless $options.show_banner
	puts <<BANNER
.__  ._____.  ___.         .__.__       .___ __                .__   
|  | |__\\_ |__\\_ |__  __ __|__|  |    __| _//  |_  ____   ____ |  |  
|  | |  || __ \\| __ \\|  |  \\  |  |   / __ |\\   __\\/  _ \\ /  _ \\|  |  
|  |_|  || \\_\\ \\ \\_\\ \\  |  /  |  |__/ /_/ | |  | (  <_> |  <_> )  |__
|____/__||___  /___  /____/|__|____/\\____ | |__|  \\____/ \\____/|____/
             \\/    \\/                    \\/                          
BANNER
end


def puts_banner text, col = 40, char = '*'
	puts ''.rjust(col, char)
	puts "*#{text.center(col -2 )}*"
	puts ''.rjust(col, char)
end

#######################################
### Options and parameters handling ###
#######################################

	DEFAULT_LIBRARIES_LIST = 'libraries.desc'
	$options = OpenStruct.new(
			:show_banner    => true,
			:libraries_list   => DEFAULT_LIBRARIES_LIST,
			:rebuild => false,
			:install_dir => "#{Dir.pwd}/#{`uname -s`.rstrip}/#{`uname -m`.rstrip}",
			:work_dir => "#{current_dir}/workdir",
			:platform => nil,
	)

	@optionParser = OptionParser.new do |opts|
		opts.banner =  "Usage : #{File.basename $PROGRAM_NAME} [OPTION]"
		opts.separator 'Execute the build libraries listed by the given libraries list.'

		opts.separator ''
		opts.separator 'Global options'

		opts.on('-h', '--help', 'Shows this help.') do
			showBanner
			puts opts
			if $options.platform.respond_to? 'list_options'
				$options.platform.list_options
			end
			exit
		end

		opts.on('-r', '--rebuild', 'Rebuild all the lib instead of building the remaining libs.') do
			$options.rebuild = true
		end

		opts.on('--no-banner', 'Do not output the ASCII art banner.') do
			$options.show_banner = false
		end


		opts.on('-l', '--libraries-list', '=FILENAME', 'Libraries list to use.', "Default: #{DEFAULT_LIBRARIES_LIST}") do |file|
			$options.libraries_list = file
		end

		opts.separator ''
		opts.separator 'Platform options'
		opts.on('-P', '--list-platforms', 'Prints a list of available platforms.') do
			puts 'List of available platforms:'
			Platforms.list_classes.each do |g|
				puts "  #{g}"
			end
			exit 0
		end

		opts.on('-d', '--desc-dir', '=DIR', 'Location of the libraries descriptions.') do |desc_dir|
			$options.desc_dir = desc_dir
		end

		opts.on('-p', '--platform', '=PLATFORM', 'Name of the platform file to use.') do |platform|
			$options.platform = Platforms.get_platform platform
			$options.platform = $options.platform.new
			$options.platformName = platform
		end

		opts.on('--list-platform-options', 'Lists the options of the platform.') do
			unless $options.platform
				raise 'The platform has to be selected before listing its options.'
			end
			unless $options.platform.respond_to? 'list_options'
				raise 'The platform has no way to list its options.'
			end
			$options.platform.list_options
			exit 0
		end

	end
@optionParser.permute!

$options.platform.permute! if 	$options.platform




showBanner

libraries = []


#parsing libraries.desc
begin
	eval(File.open("#{$options.libraries_list}").read)
rescue Exception => e
	puts "Crashed while reading the libraries list!!!"
	puts e.backtrace
	puts e
end

###############################
### Global state resolution ###
###############################

work_dir         = $options.work_dir
build_cache_path = "#{work_dir}/built.json"
source_dir       = "#{work_dir}/src"
build_dir        = "#{work_dir}/build"

$global_state = OpenStruct.new()
$global_state.work_dir = work_dir
$global_state.build_cache_path = build_cache_path
$global_state.source_dir = source_dir
$global_state.build_dir = build_dir
$global_state.current_dir = current_dir


#############################
### Directory Preparation ###
#############################
build_cache = []
if Dir.exist? work_dir
	if $options.rebuild
		FileUtils.rm_rf build_dir
	else
		build_cache = JSON.parse(File.read(build_cache_path)) if File.exist? build_cache_path
	end

end
	FileUtils.rm_rf build_dir if Dir.exist? build_dir

	FileUtils.mkdir_p $options.install_dir


	FileUtils.mkdir_p work_dir
	FileUtils.mkdir_p source_dir
	FileUtils.mkdir_p build_dir

masterBuildOptions = nil
if defined? $options.platform.build_options and not $options.platform.build_options.nil?
	masterBuildOptions = $options.platform.build_options
else
	masterBuildOptions =  ArrayStruct.new()
end
masterBuildOptions.prefix = $options.install_dir

#################################
### Libraries build iteration ###
################################
libraries.each do |desc_filename|
		next if build_cache.include? desc_filename
		build_options = masterBuildOptions.clone

		begin
			Dir.chdir $global_state.current_dir
			# Holder for the library configuration.
			library = Library.new

			# Default values
			library.build   = Build.configure_make
			library.install = Install.make_install

			eval(File.open("#{desc_filename}").read)

			puts
			puts_banner library.name
			puts

			# The fetch method used is dependent of the configuration.
			library.fetch ||= ((library.url.nil? and not library.path.nil?) ?  Fetch.local : Fetch.http)

### FETCH ###
			Dir.chdir $global_state.source_dir

			if not File.exist? library.archive and library.fetch
				scriptSuccess = library.fetch.call library
				throw "Fetch script failed for #{library.name}" if not scriptSuccess
			end

### HASH ###
			Dir.chdir $global_state.source_dir

			archiveIsValid = true
			archiveIsValid = Functions.checkFileHash library.hash, library.archive if library.hash

			if not archiveIsValid
				throw "Hash for #{library.name} do not match with the given archive."
			end

### UNPACK ###
			Dir.chdir $global_state.current_dir

			FileUtils.mkdir_p build_dir
			if not library.unpack
				if(library.archive.include? '.tar' or library.archive.include? 'tgz')
					library.unpack = Unpack.tar
				elsif(library.archive.include? '.zip')
					library.unpack = Unpack.zip
				end
			end
			library.work_dir = "#{build_dir}/#{library.name}"
			FileUtils.rm_rf library.work_dir if Dir.exist? library.work_dir
			FileUtils.mkdir_p library.work_dir
			scriptSuccess = library.unpack.call library, source_dir, library.work_dir
			throw "Unpack script failed for #{library.name}" if not scriptSuccess

			if library.build_subdir.nil?
				to_ignore = ["__MACOSX", ".", ".."]
				listing = Dir.entries library.work_dir
				to_ignore.each do |ignored|
					listing.delete ignored
				end
				# If there's only one component in the directory, go into it.
				library.build_subdir = (listing.first) if listing.length == 1
			end


### PATCH ###
			Dir.chdir $global_state.current_dir
			unless library.patcher
				unless library.patch.nil?
					if File.directory? library.patch then
						library.patcher = Patch.copy
					else
						# library.patcher = Patch.copy
					end
				end
			end

			if library.patcher
				scriptSuccess = library.patcher.call library, build_options
				throw "Patch script failed for #{library.name}" if not scriptSuccess
			end


### PREPARE BUILD ###
			Dir.chdir $global_state.current_dir

			if library.prepareBuild
				scriptSuccess = library.prepareBuild.call library, build_options
				throw "PrepareBuild script failed for #{library.name}" if not scriptSuccess
			end

### BUILD ###
			Dir.chdir $global_state.current_dir

			if library.build
				scriptSuccess = library.build.call library, build_options
				throw "Build script failed for #{library.name}" if not scriptSuccess
			end

### INSTALL ###
			Dir.chdir $global_state.current_dir

			if library.install
				library.install = Install.make_install if not library.install
				scriptSuccess = library.install.call library, build_options
				throw "Install script failed for #{library.name}" if not scriptSuccess
			end


			build_cache << desc_filename
			File.write(build_cache_path, JSON.generate(build_cache))

		rescue Exception => e
			#FileUtils.rm_rf build_dir
			puts "Crashed while building #{desc_filename}!!"
			puts e.backtrace
			puts e
			abort
		end
end

puts_banner 'Done!'
